#!/bin/bash

echo "Loading files.."

# Source some files
. src/var
. src/const
. src/log
. src/internals
. src/functions
. src/executor
. src/menu
. src/tuple
. src/storage
. src/signals
. src/printer
. src/metadata
. src/md_attrs
. src/md_table
. src/md_schema
. src/md_sequences

echo "Loaded"

: <<'FUNCTION'
Description: Do some checks before initializing the program
Parameters:
  $1 - this MUST be the args received in the program
FUNCTION
do_pre_init() {
	# This must be the first procedure to be called
	# [ functions ]
	find_binaries

	eval $LOGGER LOG "Initializing"

	# Just call me again so bash can do a very simple code validation
	$PRG_BASH -n $0
	RES=$?
	if [ ! $RES == 0 ]; then
		# Lets use echo, 'cause we dont know what is broken (Could be logger)
		echo "There is a problem with the code. Exiting"
		exit 1
	fi

	# Set the program name
	PROGRAM=$($PRG_BASENAME $0)

	while getopts "?svhb:d:m:c:" arg; do
		case $arg in
			v)
				LOGGER_MSG="Version: $VERSION"
				eval $LOGGER LOG
				finish 0
				;;
			h|\?)
				# [ functions ]
				show_help
				finish 0
				;;
			b)
				# Run the bootstrap and finish, nothing more
				# [ bootstrap ]
				DO_BOOTSTRAP=1
				;;
			d)
				DBDATA="${OPTARG}"
				;;
			s)
				STRACE=1
				;;
			m)
				MENUOPTION="${OPTARG}"
				;;
			c)
				INPUT_COMMAND=1
				CMD="${OPTARG}"
				;;
		esac
	done

	if [ "$STRACE" == "1" ]; then
		eval $LOGGER LOG "Starting strace"

		PID=$$
		sudo strace -s 100 -f -tt -p $PID -o temp/strace.tmp 2>/dev/null &
	fi

	# Install signals trap
	# [ signals ]
	signal_install

	# Run bootstrap process?
	if [ $DO_BOOTSTRAP ]; then
		# Import the necessary file
		. bootstrap

		# [ bootstrap ]
		bootstrap $DBDATA
		finish 0
	fi

	# [ functions ]
	check_data_dir $DBDATA

	cd $DBDATA

	if [ ! -z $MENUOPTION ]; then
		case "$MENUOPTION" in
			# [ menu ]
			s) menu_list_schemas ;;
			t) menu_list_tables ;;
			S) menu_list_sequences ;;
			l) menu_list_lang ;;
			y) menu_list_types ;;
		esac
		finish 0
	fi
}

main_loop() {
	# [ bd ]
	do_pre_init "$@"

	eval $LOGGER DEBUG1 "Using database folder: $DBDATA"
	eval $LOGGER LOG "Program ready"
	eval $LOGGER LOG "Type help for menu or exit to finish"

	# This is the program main loop, ethernal
	while [ true ]; do
		# [ functions ]
		# ask_for_input exposes INPUT_CMD
		if [ -z $INPUT_COMMAND ]; then
			ask_for_input
		else
			LOGGER_MSG="Command: $CMD"
			eval $LOGGER DEBUG1
			INPUT_CMD="${CMD}"
		fi

		LOGGER_MSG="Input '${INPUT_CMD}'"
		eval $LOGGER DEBUG1

		# Help or subcommand
		if [ "${INPUT_CMD:0:1}" == "\\" ] ||
		   [ "${INPUT_CMD^^}" == "HELP" ]; then
			# [ menu ]
			cmd_menu "${INPUT_CMD}"
			continue
		fi

		# Oh no, I'd like to see you soon
		if [ "${INPUT_CMD^^}" == "EXIT" ]; then
			eval $LOGGER LOG "Exiting program"

			# Exit with 0 'cause I still love u
			finish 0
		fi

		# So, lets process this (probably) SQL command
		# [ executor ]
		execute "$INPUT_CMD"

		if [ ! -z $INPUT_COMMAND ]; then
			return 0
		fi
	done
}

########################
#######   MAIN   #######
########################

# Initialize this variable with a default value to not break
#  LOGGER calls
PRG_PRINTF="printf"

# [ bd ]
main_loop "$@"
